<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Monats-Schätzung</title>
  <style>
    :root{
      --bg:#ffffff;
      --card:#ffffff;
      --border:#e9eef3;
      --text:#0f172a;
      --muted:#64748b;
      --grid:#eef2f6;

      --spot:#94a3b8;     /* Spot (Day-Ahead) */
      --spotFill: rgba(148,163,184,.06);

      --est:#22c55e;      /* Schätzung (gewichtet) */
      --estFill: rgba(34,197,94,.08);

      --marker:#cbd5e1;
      --valueBlue:#2563eb;

      --tooltipBg:#0f172a;
      --tooltipText:#ffffff;

      --chartBg:#fbfdff;
    }

    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .wrap{max-width:1100px; margin:24px auto; padding:0 16px;}

    .panel{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:14px;
      padding:14px;
    }
    .panelHead{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:16px;
      margin-bottom:10px;
    }
    .panelHead h1{font-size:18px; margin:0; font-weight:700;}
    .sub{font-size:12px; color:var(--muted);}

    /* eigener Chart-Container */
    .chartCard{
      border:1px solid var(--border);
      background:var(--chartBg);
      border-radius:12px;
      padding:10px;
    }

    .canvasWrap{
      position:relative;
      border-radius:10px;
      overflow:hidden;
      background:#fff;
    }
    canvas{width:100%; height:360px; display:block;}

    .hint{margin-top:10px; font-size:12px; color:var(--muted);}
    .err{
      margin-top:10px; padding:10px 12px; border-radius:10px;
      background:#fff7ed; border:1px solid #fed7aa; color:#9a3412; font-size:12px;
      display:none;
    }

    /* Tooltip */
    .tip{
      position:absolute;
      pointer-events:none;
      transform:translate(-50%, calc(-100% - 10px));
      background:var(--tooltipBg);
      color:var(--tooltipText);
      padding:6px 8px;
      border-radius:8px;
      font-size:12px;
      white-space:nowrap;
      box-shadow:0 6px 18px rgba(0,0,0,.14);
      display:none;
      z-index:5;
    }
    .tip:after{
      content:"";
      position:absolute;
      left:50%;
      bottom:-6px;
      transform:translateX(-50%);
      border:6px solid transparent;
      border-top-color:var(--tooltipBg);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="panelHead">
        <div>
          <h1>Monatsmarktwert Wind Onshore – Spot & Schätzung</h1>
          <div class="sub" id="subline">–</div>
        </div>
        <div class="sub" id="updated">–</div>
      </div>

      <div class="chartCard">
        <div class="canvasWrap" id="canvasWrap">
          <canvas id="chart"></canvas>
          <div class="tip" id="tip"></div>
        </div>
      </div>

      <div class="err" id="err"></div>

      <div class="hint">
        Hinweis: Schätzung = Spotmarktpreis (Energy-Charts) gewichtet mit Wind-Onshore-Erzeugung (SMARD).
      </div>
    </div>
  </div>

<script>
(() => {
  const PATH_CURRENT = "../data/price_current_month.json";
  const PATH_PREV    = "../data/price_prev_month.json";

  const elSub = document.getElementById("subline");
  const elUpd = document.getElementById("updated");
  const elErr = document.getElementById("err");

  const wrap = document.getElementById("canvasWrap");
  const tip  = document.getElementById("tip");

  const c = document.getElementById("chart");
  const ctx = c.getContext("2d");

  const getDpr = () => Math.max(1, window.devicePixelRatio || 1);

  const MONTHS = ["Januar","Februar","März","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"];
  function monthName(yyyyMm){
    const [y,m] = (yyyyMm || "").split("-").map(Number);
    if(!y || !m) return "–";
    return `${MONTHS[m-1]} ${y}`;
  }

  // €/MWh -> ct/kWh
  const eurMwhToCtKwh = (v) => (v == null || !isFinite(v) ? null : v * 0.1);
  const fmtCtKwh = (vCt) => (vCt == null || !isFinite(vCt) ? "–" : `${vCt.toFixed(2).replace(".", ",")} ct/kWh`);

  function parseLabel(label){
    const m = (label || "").match(/^(\d{2})\.(\d{2})\s+(\d{2}):00$/);
    if(!m) return null;
    return { dd:+m[1], mm:+m[2], hh:+m[3] };
  }

  async function loadJson(url){
    const bust = `?v=${Date.now()}`;
    const r = await fetch(url + bust, { cache:"no-store" });
    if(!r.ok) throw new Error(`Fetch ${url} failed: ${r.status}`);
    return await r.json();
  }

  function resize(dpr){
    const rect = c.getBoundingClientRect();
    c.width  = Math.round(rect.width * dpr);
    c.height = Math.round(rect.height * dpr);
  }

  function to6hSeries(series){
    const out = [];
    for(const p of (series || [])){
      const t = parseLabel(p.label);
      if(!t) continue;
      const y = +p.value;
      if(!isFinite(y)) continue;
      out.push({
        x: (t.dd - 1) + (t.hh / 24),
        y,
        dd:t.dd, mm:t.mm, hh:t.hh,
        label:p.label
      });
    }
    out.sort((a,b)=>a.x-b.x);
    return out;
  }

  function lastPoint(series){
    const s = to6hSeries(series);
    return s.length ? s[s.length-1] : null;
  }

  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  // Hover: nearest X + Toleranz
  let hoverBound = false;
  function bindHover(){
    if(hoverBound) return;
    hoverBound = true;

    wrap.addEventListener("mousemove", (ev) => {
      const dpr = getDpr();
      const rect = wrap.getBoundingClientRect();
      const mx = (ev.clientX - rect.left) * dpr;

      const pts = window.__mw_points || [];
      const xPx = window.__mw_xpx || [];
      if(!pts.length){
        tip.style.display = "none";
        return;
      }

      let bestIdx = -1, bestDist = Infinity;
      for(let i=0;i<xPx.length;i++){
        const dist = Math.abs(xPx[i] - mx);
        if(dist < bestDist){ bestDist = dist; bestIdx = i; }
      }

      const tol = 18 * dpr;
      if(bestIdx >= 0 && bestDist <= tol){
        const p = pts[bestIdx];

        const head = `${String(p.dd).padStart(2,"0")}.${String(p.mm).padStart(2,"0")} ${String(p.hh).padStart(2,"0")}:00`;
        const spot = (p.spotCt != null) ? `Spot: ${fmtCtKwh(p.spotCt)}` : `Spot: –`;
        const est  = (p.estCt  != null) ? `Schätzung: ${fmtCtKwh(p.estCt)}` : `Schätzung: –`;

        tip.style.display = "block";
        tip.textContent = `${head} – ${spot} – ${est}`;
        tip.style.left = `${(p.px / dpr)}px`;
        tip.style.top  = `${(p.py / dpr)}px`;
      }else{
        tip.style.display = "none";
      }
    });

    wrap.addEventListener("mouseleave", () => tip.style.display = "none");
  }

  function draw(current, prev){
    const dpr = getDpr();
    resize(dpr);

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,c.width,c.height);
    ctx.lineJoin = "round";
    ctx.lineCap  = "round";

    const W = c.width, H = c.height;

    // Layout
    const padL = 18*dpr, padT = 14*dpr, padB = 30*dpr, padR = 18*dpr;

    const labelZone = Math.round(260 * dpr);
    const gapToLabel = Math.round(16 * dpr);

    const plotW = W - padL - padR - labelZone - gapToLabel;
    const plotH = H - padT - padB;
    const plotX0 = padL;
    const plotY0 = padT;
    const labelX0 = plotX0 + plotW + gapToLabel;

    const css = getComputedStyle(document.documentElement);
    const colGrid   = css.getPropertyValue("--grid").trim();
    const colSpot   = css.getPropertyValue("--spot").trim();
    const colSpotF  = css.getPropertyValue("--spotFill").trim();
    const colEst    = css.getPropertyValue("--est").trim();
    const colEstF   = css.getPropertyValue("--estFill").trim();
    const colMarker = css.getPropertyValue("--marker").trim();
    const colBorder = css.getPropertyValue("--border").trim();
    const colMuted  = css.getPropertyValue("--muted").trim();
    const colBlue   = css.getPropertyValue("--valueBlue").trim();

    // Daten: Spot (neu) + Schätzung (alt)
    const spotSeriesRaw = current.series_6h_spot;     // <-- kommt aus Worker (neu)
    const estSeriesRaw  = current.series_6h;          // <-- existiert bereits

    let spot = to6hSeries(spotSeriesRaw);
    let est  = to6hSeries(estSeriesRaw);

    // Startanker für beide
    const prevSpotLast = lastPoint(prev.series_6h_spot);
    const prevEstLast  = lastPoint(prev.series_6h);

    if(prevSpotLast && spot.length) spot = [{...prevSpotLast, x:-0.25, label:"Vormonat"} , ...spot];
    if(prevEstLast  && est.length)  est  = [{...prevEstLast,  x:-0.25, label:"Vormonat"} , ...est];

    // Mindestens eine Serie muss da sein
    const hasSpot = spot.length >= 2;
    const hasEst  = est.length >= 2;

    if(!hasSpot && !hasEst){
      elErr.style.display = "block";
      elErr.textContent = "Keine Daten: series_6h (Schätzung) und series_6h_spot (Spot) sind leer.";
      return;
    }
    elErr.style.display = "none";

    const [yy, mm] = (current.month || "").split("-").map(Number);
    const daysInMonth = new Date(yy, mm, 0).getDate();

    const xMin = -0.5;
    const xMax = (daysInMonth - 1) + 18/24;

    // y-range über beide Serien
    const yAll = []
      .concat(hasSpot ? spot.map(p=>p.y) : [])
      .concat(hasEst  ? est.map(p=>p.y)  : []);
    let yMin = Math.min(...yAll);
    let yMax = Math.max(...yAll);
    const padY = (yMax - yMin) * 0.12 || 8;
    yMin -= padY; yMax += padY;

    const xToPx = x => plotX0 + (x - xMin) / (xMax - xMin) * plotW;
    const yToPx = y => plotY0 + (yMax - y) / (yMax - yMin) * plotH;

    // Grid
    ctx.lineWidth = 1*dpr;
    ctx.strokeStyle = colGrid;
    ctx.beginPath();
    for(let i=0;i<=4;i++){
      const gy = plotY0 + (plotH/4)*i;
      ctx.moveTo(plotX0, gy);
      ctx.lineTo(plotX0 + plotW, gy);
    }
    ctx.stroke();

    // Clip plot area
    ctx.save();
    ctx.beginPath();
    ctx.rect(plotX0, plotY0, plotW, plotH);
    ctx.clip();

    // Spot: Fläche + Linie (Hauptsächlich)
    if(hasSpot){
      ctx.beginPath();
      ctx.moveTo(xToPx(spot[0].x), yToPx(spot[0].y));
      for(const p of spot) ctx.lineTo(xToPx(p.x), yToPx(p.y));
      ctx.lineTo(xToPx(spot[spot.length-1].x), plotY0 + plotH);
      ctx.lineTo(xToPx(spot[0].x), plotY0 + plotH);
      ctx.closePath();
      ctx.fillStyle = colSpotF;
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(xToPx(spot[0].x), yToPx(spot[0].y));
      for(const p of spot) ctx.lineTo(xToPx(p.x), yToPx(p.y));
      ctx.strokeStyle = colSpot;
      ctx.lineWidth = 2*dpr;
      ctx.stroke();
    }

    // Schätzung: Linie (zweitrangig)
    if(hasEst){
      ctx.beginPath();
      ctx.moveTo(xToPx(est[0].x), yToPx(est[0].y));
      for(const p of est) ctx.lineTo(xToPx(p.x), yToPx(p.y));
      ctx.strokeStyle = colEst;
      ctx.lineWidth = 2*dpr;
      ctx.stroke();
    }

    ctx.restore();

    // Marker (vertikal) im Plot
    const dayIndex = Math.min(Math.max(0, +current.today_index || 0), daysInMonth-1);
    const xNow = xToPx(dayIndex + 12/24);

    ctx.save();
    ctx.beginPath();
    ctx.rect(plotX0, plotY0, plotW, plotH);
    ctx.clip();
    ctx.strokeStyle = colMarker;
    ctx.lineWidth = 2*dpr;
    ctx.beginPath();
    ctx.moveTo(xNow, plotY0);
    ctx.lineTo(xNow, plotY0 + plotH);
    ctx.stroke();
    ctx.restore();

    // yNow: nimm Spot wenn vorhanden, sonst Schätzung
    function lastBefore(series){
      for(let i=series.length-1;i>=0;i--){
        const p = series[i];
        if(p.label === "Vormonat") continue;
        if(xToPx(p.x) <= xNow + 0.0001) return p;
      }
      return series[series.length-1];
    }
    const pNowSpot = hasSpot ? lastBefore(spot) : null;
    const pNowEst  = hasEst  ? lastBefore(est)  : null;

    const yNow = yToPx((pNowSpot?.y ?? pNowEst?.y));

    // Connector (dünn, durchgehend bis kurz vor Text)
    const stopX = labelX0 - (10*dpr);
    ctx.strokeStyle = colMarker;
    ctx.lineWidth = 1*dpr; /* dünner */
    ctx.beginPath();
    ctx.moveTo(xNow, yNow);
    ctx.lineTo(stopX, yNow);
    ctx.stroke();

    // Linke “Überschrift” im Plot (Legende)
    const legX = plotX0 + 10*dpr;
    const legY = plotY0 + 18*dpr;

    ctx.textAlign = "left";
    ctx.textBaseline = "alphabetic";
    ctx.font = `${12*dpr}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;

    // Spot label
    ctx.fillStyle = colSpot;
    ctx.fillText(hasSpot ? "Spot (Day-Ahead)" : "Spot (Day-Ahead) – fehlt", legX, legY);

    // Est label
    ctx.fillStyle = colEst;
    ctx.fillText(hasEst ? "Schätzung (gewichtet)" : "Schätzung – fehlt", legX, legY + 16*dpr);

    // Rechte Werte: “Schätzung Marktpreis” + Monatswerte (mit Trennlinie)
    const curName = monthName(current.month);
    const prevName = monthName(prev.month);

    const estCurCt = eurMwhToCtKwh(current.estimate_eur_mwh);
    const prevIsOfficial = !!prev.official_available && prev.official_eur_mwh != null;
    const prevValCt = eurMwhToCtKwh(prevIsOfficial ? prev.official_eur_mwh : prev.estimate_eur_mwh);

    // Optional Spot-Monatsmittel (wenn Worker liefert)
    const spotCurCt = eurMwhToCtKwh(current.estimate_spot_eur_mwh);
    const spotPrevCt = eurMwhToCtKwh(prev.estimate_spot_eur_mwh);

    const blockH = (18+12) * dpr + 10*dpr + 1*dpr + 10*dpr + (16+12)*dpr + 16*dpr;
    const blockY = Math.max(plotY0 + 6*dpr, Math.min(plotY0 + plotH - blockH - 6*dpr, yNow - blockH/2));
    const xText = labelX0;

    // Title rechts
    ctx.fillStyle = colMuted;
    ctx.font = `${12*dpr}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.fillText("Schätzung Marktpreis", xText, blockY + 14*dpr);

    // Current
    ctx.fillStyle = colEst;
    ctx.font = `${18*dpr}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.fillText(fmtCtKwh(estCurCt), xText, blockY + 38*dpr);

    ctx.fillStyle = colMuted;
    ctx.font = `${12*dpr}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.fillText(curName, xText, blockY + 54*dpr);

    // Separator
    const sepY = blockY + 68*dpr;
    ctx.strokeStyle = colBorder;
    ctx.lineWidth = 1*dpr;
    ctx.beginPath();
    ctx.moveTo(xText, sepY);
    ctx.lineTo(xText + (labelZone - 20*dpr), sepY);
    ctx.stroke();

    // Prev
    ctx.fillStyle = colBlue;
    ctx.font = `${16*dpr}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.fillText(fmtCtKwh(prevValCt), xText, sepY + 28*dpr);

    ctx.fillStyle = colMuted;
    ctx.font = `${12*dpr}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.fillText(prevIsOfficial ? `${prevName} (offiziell)` : prevName, xText, sepY + 44*dpr);

    // Optional: Spot-Monatsmittel klein darunter (nur wenn vorhanden)
    if(spotCurCt != null || spotPrevCt != null){
      ctx.fillStyle = colSpot;
      ctx.font = `${12*dpr}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.fillText(
        `Spot (Monat): ${spotCurCt != null ? fmtCtKwh(spotCurCt) : "–"}`,
        xText, sepY + 62*dpr
      );
    }

    // X-Achse Marks
    ctx.fillStyle = colMuted;
    ctx.font = `${11*dpr}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.textAlign = "center";
    const marks = [1, 8, 15, 22, daysInMonth].filter((v,i,a)=>a.indexOf(v)===i);
    for(const d of marks){
      const x = xToPx((d-1) + 12/24);
      ctx.fillText(String(d).padStart(2,"0"), x, plotY0 + plotH + 18*dpr);
    }

    // Hover cache: wir nehmen die X-Positionen der Spot-Serie, sonst Schätzung
    // und mappen auf beide Werte per nearest label (dd/mm/hh)
    function keyOf(p){ return `${p.dd}-${p.mm}-${p.hh}`; }
    const estMap = new Map((hasEst ? est : []).filter(p=>p.label!=="Vormonat").map(p=>[keyOf(p), p]));
    const spotBase = (hasSpot ? spot : est).filter(p=>p.label!=="Vormonat");

    const pts = spotBase.map(p => {
      const k = keyOf(p);
      const e = estMap.get(k);
      const s = hasSpot ? p : null;

      const spotY = s ? s.y : null;
      const estY  = e ? e.y : null;

      const py = yToPx((spotY ?? estY));
      return {
        px: xToPx(p.x),
        py,
        dd:p.dd, mm:p.mm, hh:p.hh,
        spotCt: spotY != null ? eurMwhToCtKwh(spotY) : null,
        estCt:  estY  != null ? eurMwhToCtKwh(estY)  : null,
      };
    });

    window.__mw_points = pts;
    window.__mw_xpx = pts.map(p=>p.px);
    bindHover();
  }

  async function init(){
    try{
      const [current, prev] = await Promise.all([loadJson(PATH_CURRENT), loadJson(PATH_PREV)]);

      const [yy, mm] = (current.month || "").split("-").map(Number);
      const dim = new Date(yy, mm, 0).getDate();

      elSub.textContent = `${current.month}-01 → ${current.month}-${String(dim).padStart(2,"0")}`;
      elUpd.textContent = `Update: ${current.updated_utc || "–"}`;

      draw(current, prev);
      window.addEventListener("resize", () => draw(current, prev));
      window.addEventListener("focus", () => draw(current, prev));
    } catch(e){
      elErr.style.display = "block";
      elErr.textContent = "Fehler beim Laden der JSON: " + (e?.message || e);
    }
  }

  init();
})();
</script>
</body>
</html>
